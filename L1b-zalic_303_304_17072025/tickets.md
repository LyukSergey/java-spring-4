* **Сутності**:
    * `Department` (`id`, `name`)
    * `Employee` (`id`, `firstName`, `lastName`, `email`, `position`, `salary`)
* **Зв'язки**: `@OneToMany` у `Department`, `@ManyToOne` у `Employee`.
* **DTO**:
    * `DepartmentDto(Long id, String name)`
    * `EmployeeDto(Long id, String fullName, String position, BigDecimal salary, String departmentName)`
* **Початковий стан**: Існують пусті 
* `Controller`, `Service`, `Repository` класи. База даних наповнена тестовими даними.

---
***
### **Завдання на залік L1-B Java Spring Boot 17.07.2025**

1.  **Завдання 1:** Створити ендпоінт `GET /departments`, який повертає `List<DepartmentWithCountDto>`. Цей DTO має містити `id`, `name` та поле `employeeCount` (кількість співробітників), обчислене на рівні бази даних.
2.  **Завдання 2:** Створити ендпоінт `GET /employees/search/by-salary-range`, який приймає `minSalary` та `maxSalary` і повертає список співробітників у цьому діапазоні, відсортований за зарплатою **за спаданням**.
3.  **Завдання 3:** Створити ендпоінт `POST /departments`, який створює новий відділ. Додати валідацію, щоб назва відділу не була пустою та була унікальною.
4.  **Завдання 4:** Створити ендпоінт `GET /employees/sorted`, який повертає всіх співробітників, відсортованих спочатку за **назвою відділу (за алфавітом)**, а потім за **зарплатою (за спаданням)**.
5.  **Завдання 5:** Створити ендпоінт `GET /employees/search/by-email`, який знаходить співробітника за email, **ігноруючи регістр** літер (наприклад, 'test@example.com' і 'Test@Example.com' вважаються однаковими).
6.  **Завдання 6:** Створити ендпоінт `GET /departments/{id}/employees`, який повертає всіх співробітників у відділі, **відсортованих за прізвищем**.
7.  **Завдання 7:** Створити ендпоінт `PUT /employees/{id}`, який приймає DTO і оновлює **одночасно посаду та зарплату** співробітника.
8.  **Завдання 8:** Створити ендпоінт `GET /departments/with-employees-more-than`, який приймає параметр `count` і повертає `List<DepartmentDto>` відділів, у яких кількість співробітників **більша** за вказане число.
9.  **Завдання 9:** Створити ендпоінт `GET /employees/{id}`, який повертає `EmployeeWithNestedDepartmentDto` — DTO, що містить всю інформацію про співробітника та вкладений об'єкт `DepartmentDto` з даними його відділу.
10. **Завдання 10:** Створити ендпоінт `GET /employees`, який повертає список **всіх** співробітників.
11. **Завдання 11:** Створити ендпоінт `GET /departments/by-employee/{id}`, який знаходить і повертає `DepartmentDto` відділу, в якому працює співробітник із заданим `id`.
12. **Завдання 12:** Створити ендпоінт `DELETE /employees/{id}`, який видаляє співробітника і повертає `EmployeeDto` щойно видаленого співробітника.
13. **Завдання 13:** Створити ендпоінт `GET /departments/without-employees`, який знаходить і повертає список відділів, де немає жодного співробітника.
14. **Завдання 14:** Створити ендпоінт `GET /employees/search/by-multiple-positions`, який приймає список посад (наприклад, `?positions=Developer&positions=QA`) і повертає всіх співробітників, які обіймають одну з цих посад.
15. **Завдання 15:** Створити ендпоінт `GET /employees/search/by-fullname`, який приймає `fullName` (наприклад, "John Smith") і знаходить співробітника за повним ім'ям, вимагаючи написання власного JPQL запиту.
16. **Завдання 16:** Створити ендпоінт `GET /departments`, який повертає **всі** відділи, відсортовані за назвою **в алфавітному порядку**.
17. **Завдання 17:** Створити ендпоінт `POST /employees`, який створює нового співробітника. Додати валідацію (`@Valid`), щоб ключові поля не були пустими.
18. **Завдання 18:** Створити ендпоінт `GET /employees/search/by-lastname-and-position`, який приймає `lastName` та `position` і повертає список співробітників, що відповідають обом критеріям.
19. **Завдання 19:** Створити ендпоінт `GET /departments/search/name-containing`, який за параметром `text` знаходить `List<DepartmentDto>` відділів, назва яких містить цей текст, **незалежно від регістру**.
20. **Завдання 20:** Створити ендпоінт `GET /employees/search/by-name`, який приймає `name` і повертає `List<EmployeeDto>` співробітників, у яких **ім'я або прізвище** збігається з переданим рядком.
21. **Завдання 21:** Створити ендпоінт `PUT /employees/{employeeId}/department/{departmentId}` для переведення співробітника до нового відділу, який у відповідь повертає оновлений `EmployeeDto`.
22. **Завдання 22:** Створити ендпоінт `GET /employees/search/top-2-by-position`, який приймає `position` і знаходить двох **найбільш високооплачуваних** співробітників на цій посаді.
23. **Завдання 23:** Створити ендпоінт `GET /departments/{id}/employees/by-positions`, який приймає список посад і повертає співробітників на цих посадах **тільки** з конкретного відділу.
24. **Завдання 24:** Створити ендпоінт `GET /employees/with-unassigned-salary`, який знаходить усіх співробітників, у яких поле `salary` має значення `null`.
25. **Завдання 25:** Створити ендпоінт `GET /employees/check/exists`, який приймає `firstName` та `lastName` і повертає `boolean`, чи існує співробітник з такою комбінацією імені та прізвища.